# 인터럽트 브릿지

## 용도
MMORPG를 만들고, AI를 서버에서 구동하는 경우를 상상해 봅시다.
AI가 액션을 결정해서 실행하고, 액션이 종료되면 제어권을 다시 AI가 넘겨받아서 그 다음으로 할 액션을 고를 것입니다.
이것은 AI 프로시저가 액션 프로시저를 함수호출하는 것과 개념상 같지요.
그러나 액션 프로시저에서 블록된 채로 한동안 리턴하지 않아야 하기 때문에, 일반 함수호출로는 구현할 수 없습니다.
하지만 파이버 안에서 AI 프로시저가 액션 프로시저를 함수 호출한다고 생각하면 매우 자연스럽습니다.
AI가 붙어있는 게임 오브젝트 하나마다 파이버 하나를 만들고, 액션을 수행하는 일정 시간 동안 파이버를 잠깐 대기시키면 됩니다.
파이버 하나당 차지하는 메모리가 크지 않기 때문에 가능합니다. AI 오브젝트가 10,000개 있으면 22MB 정도 됩니다.

그런데, 이 경우에는 파이버를 일정 시간 대기시키는 데 `EngineAPI.Fibering.Sleep` 을 쓸 수 없습니다.
왜냐하면, 선공몹이 로밍하던 중에 적대적 대상을 발견하거나, 채집 액션 중에 얻어맞아서 채집을 취소해야 하는 경우 등
외부의 방해를 받으면 AI가 즉시 깨어나서 다음 행동을 결정해야 하기 때문입니다.

이런 곳에 `EngineAPI.Fibering.Sleep` 대신 `IInterruptBridge.Wait`을 사용할 수 있습니다.

## 인터럽트 브릿지
`EngineAPI.Fibering.CreateInterruptBridge` 를 호출하면 인터럽트 브릿지 객체가 생깁니다.

대기하려는 파이버는 자신의 게임 오브젝트 객체를 통해 이 인터럽트 브릿지를 노출해 놓고,
인터럽트 브릿지에 대해 `Wait`을 호출해두면 됩니다.

- 인자로 지정한 시간이 지날 때까지 인터럽트 브릿지를 통해 `Interrupt`를 당하지 않았다면,
  파이버가 재개되면서 `Wait`의 리턴값으로 null을 받게 됩니다.

- 어딘가 다른 곳에서 인터럽트 브릿지에 `Interrupt`를 호출하면,
  `Wait`이 즉시 리턴하면서 `Interrupt`의 인자로 전달했던 값을 그대로 받게 됩니다.

자세한 동작과 사용법은 `IInterruptBridge` 인터페이스의 주석을 참고하세요.
