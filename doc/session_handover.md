### 세션 재연결
#### 개요
모바일 환경에서는 게임 클라이언트를 사용하는 동안 TCP 연결을 계속 유지하고 있기 어렵습니다. 클라이언트가 WIFI에서 LTE로 갈아타는 경우나 앱이 백그라운드로 내려갔다가 올라오는 경우에 TCP 연결이 끊길 수 있습니다.

EngineAPI.Networking을 사용하면 TCP 연결이 끊기는 경우에 자동으로 재접속합니다. 보낸 메시지를 잠시 보관해 두었다가 재접속 후에 자동으로 다시 보냅니다. 보관했던 메시지를 버리는 것은 상대편에서 메시지를 수신한 것이 확인된 시점입니다.

#### 로드밸런서 문제
게임 서버를 AWS ELB(Elastic Load Balancer)와 같은 로드밸런서 뒤에 배치할 경우, 클라이언트가 재접속할 때 아까와 같은 서버 프로세스에 접속할 수 있다는 보장이 없습니다. 게임 서버를 로드밸런서 뒤에 놓으면서 세션 재연결을 활용하고 싶은 경우에는, 로드밸런서를 통해서 게임 서버에 접속할 수 있는 동시에 게임 서버마다 공용 IP를 하나씩 할당하기를 권장합니다. 그러면 클라이언트가 서버에 처음으로 접속할 때는 로드밸런서를 통해 접속하고, 끊겼다가 다시 접속할 때는 아까 접속했던 서버의 공용 IP로 접속합니다.

### 세션 핸드오버
#### 개요
클라이언트가 재접속할 때 방금 전 접속했던 바로 그 서버 프로세스가 아니더라도, 새로 접속한 프로세스로 세션을 넘겨받아서 게임을 계속할 수 있습니다. 그 과정에서 클라이언트와 서버가 서로 주고받는 메시지는 손실되지 않으며, 클라이언트 게임 로직은 아무것도 신경쓸 필요가 없습니다. 수 초 정도 통신이 늦어지는 것처럼 보일 뿐입니다.

#### 세션 재연결 대비 장점
- 게임 서버에 공용 IP를 할당하지 않으면서 로드밸런서 뒤에 놓을 수 있습니다.
- 게임 경험에 영향을 주지 않으면서 게임 서버를 끄고 업데이트할 수 있습니다. 게임 서버를 끌 때 그 서버에 연결된 세션들이 모두 직렬화되어 저장되고, 클라이언트가 스스로 재접속하면서 다른 프로세스에 복원될 것입니다.

#### 사용하는 법
- 세션 핸들러의 `SessionDestroyed()`에서 인자 `swapOut`이 true로 들어오면, 세션 핸들러를 `byte[]`로 직렬화해서 리턴하도록 합니다.
- `byte[]`로부터 세션 핸들러를 복원하는 코드를 만들어서 `EngineAPI.Networking.Listen`에 전달합니다.

#### 제약
세션 핸들러가 안전하게 다른 서버 프로세스로 이동할 수 있으려면, 세션이 프로세스 안의 다른 부분과 별다른 관계를 맺고 있지 않아야 합니다.
- 세션에서 하는 일의 거의 대부분이 DB 입출력인 퍼즐 게임에 세션 핸드오버를 적용하기 좋습니다.
- 다른 서버 프로세스로 이동하면 현재의 플레이 맥락이 깨지는 MMORPG 게임에는 세션 핸드오버를 적용할 수 없습니다.
- 턴제 대전 게임은 세션 핸드오버를 적용할 수 있도록 만들 수 있습니다. 게임 로직을 VActor 안에서 돌리고, 아래의 '서버간 메시지를 안전하게 처리하기' 를 신경쓰면 됩니다.

#### 서버간 메시지를 안전하게 처리하기
서버에서 세션을 상대로 발송하는 메시지는 핸드오버 과정에서 손실될 수 있습니다. `EngineAPI.Networking.SessionHandler`의 `SendGameLogicMessageToServer`, `QueueToLocalSession` 이 여기 해당됩니다. 손실되면 안되는 메시지는 다음 과정을 거쳐 발송하십시오.
- `EngineAPI.Queue`에 메시지 내용을 먼저 저장합니다.
  - 세션 핸드오버가 일어날 때 세션 id가 바뀌지 않으므로, 큐 이름에는 수신자의 세션 id를 사용하면 됩니다.
  - 세션이 살아있을 수 있는 최대 시간 + a로 expire 시간을 설정합니다.
- `EngineAPI.Networking.SessionHandler.SendGameLogicMessageToServer`로 메시지를 확인하라고만 보냅니다.
- 위 메시지를 수신한 시점, 그리고 세션 핸드오버를 마친 시점에 `EngineAPI.Queue.DequeueAll`로 메시지를 모두 가져와서 하나씩 처리합니다.
